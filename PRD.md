# Product Requirements Document (PRD): Pivotr Mailer Automation

## 1. Executive Summary

**Pivotr Mailer** is an internal B2B email automation tool designed to streamline personalized outreach to imported leads. Unlike mass-marketing newsletters, this application focuses on sending highly personalized, text-based emails that mimic human behavior.

The application operates in a containerized environment (Docker on Windows) on intermittent hardware. It prioritizes delivery reputation through strict verification processes, Gaussian-distributed sending patterns, and robust state management.

## 2. Technical Context & Constraints

* **Infrastructure:** Self-hosted Appwrite (Backend-as-a-Service) via Docker Compose.
* **Frontend:** TanStack Start (React 19, Vite, TanStack Router).
* **Runtime:** Bun (Strict dependency management).
* **Environment:** Localhost (Windows Mini PC). The system must tolerate abrupt shutdowns (PC power-off) and resume gracefully.
* **External Services:** AWS SES (Sending), AWS SQS (Event Feedback), MyEmailVerifier (Verification), Google Workspace (Domain Auth).

---

## 3. Core Functional Requirements

### 3.1. Lead Management & Ingestion

* **Data Import:**
    * The system must accept lead data via Manual UI Entry and Bulk Import (Excel/CSV).
    * **Required Fields:** Person Name, Email Address, Company Name.


* **Data Sanitization:**
    * Incoming data must be scrubbed for invisible characters, whitespace, duplicates, and invalid email addresses.

* **Indian Name Parsing Logic:**
    * A dedicated logic module is required to parse full names specifically for the Indian demographic.
    * The system must intelligently identify "First Name" for personalization, handling common formats (e.g., honorifics, initials, reversed Last/First ordering) to ensure the email greeting sounds natural.



### 3.2. Template Engine & Spintax

* **Spintax Support:**
    * The system must support Spintax (Spin Syntax) in both the **Email Subject** and **Email Body**.
    * *Example logic:* `{Hi|Hello|Hey}` generates a unique variant for every email sent.


* **Personalization Injection:**
    * Templates must support dynamic variable insertion (e.g., `{{FirstName}}`, `{{Company}}`) derived from the lead data and the Name Parser output.



### 3.3. The Sending Engine (Backend Core)

The sending engine is an event-driven loop that prioritizes safety and human-like behavior over speed.

#### 3.3.1. Verification Pipeline (Just-In-Time)

* **Flow:** Trigger -> Verifier API -> Validation Logic -> Send -> Timer.
* **Pipelining Optimization:** To mitigate API latency, the system must **pre-verify the next email** in the queue while the current email is undergoing its delay timer. The system should strictly *not* bulk verify all leads upfront to conserve credits and ensure fresh status.
* **Validation Logic:**
    * If `Valid`: Proceed to Send.
    * If `Invalid/Risky`: Mark as skipped in the database, log the reason, and immediately proceed to the next lead without waiting for the send timer.



#### 3.3.2. Gaussian Distribution Timing

* **Pulse Scheduling:** Emails must not be sent at fixed intervals. The system must utilize a Gaussian distribution (Bell Curve) algorithm to calculate delay intervals (e.g., random delay between 1 to 3 minutes).
* **Purpose:** To mimic manual human sending behavior and avoid spam filters.

#### 3.3.3. State Management & ACID Compliance

* **Controls:** The user must have UI controls for `Start`, `Pause`, and `Abort`.
* **Atomic Operations:**
    * The system must adhere to **ACID** (Atomicity, Consistency, Isolation, Durability) principles.
    * A "Send" operation is a transaction. If the system is paused or the PC loses power, the current transaction must either complete fully or roll back to a "Pending" state. No email should be recorded as sent if it wasn't, and vice-versa.


* **Persistence:** The pause state and queue position must be persisted in the Appwrite database, allowing the application to resume exactly where it left off after a restart.

### 3.4. External Integrations (API Layer)

* **AWS SES (Simple Email Service):**
    * Used strictly for the transmission of the email.


* **AWS SQS (Simple Queue Service):**
    * The application must poll or listen to SQS queues to ingest feedback events (Bounces, Complaints) generated by SES via SNS.
    * This feedback must update the specific lead's status in the database immediately to prevent future sending to damaged addresses.


* **MyEmailVerifier:**
    * API integration for the JIT verification step described in section 3.3.1.



---

## 4. Data Strategy & Logging

### 4.1. Comprehensive Audit Logging

Every action must be recorded in an immutable log table for future audit and debugging.

* **Log Entities:**
    * Timestamp of action.
    * Specific Spintax variant used (actual text sent).
    * Verifier API raw response.
    * SES Message ID.
    * SQS Bounce/Complaint details (if applicable).
    * Processing time per lead.



### 4.2. Analytics & Metrics

* **Aggregated Metrics Table:**
    * Metrics must **not** be calculated on-the-fly by querying the raw logs (to ensure performance).
    * A dedicated `Metrics` table must be updated atomically via database triggers or application logic whenever an event occurs (e.g., Email Sent, Bounce Received).


* **Key Data Points:** (To be defined in detail later, but includes Total Sent, Bounce Rate, Open Rate, Verification Pass Rate).

---

## 5. Non-Functional Requirements

### 5.1. Performance & Reliability

* **Resource Usage:** The application runs on a mini-PC with limited resources. Memory leaks must be prevented, particularly in the event loop.
* **Fault Tolerance:** Network failures (e.g., Verifier API down) should trigger a retry mechanism with exponential backoff before pausing the queue and alerting the user.

### 5.2. Security

* **Credential Management:** AWS keys and API tokens must be stored securely using Appwrite Functions environment variables or secure storage, never hardcoded.
* **Domain Verification:** Any necessary Google Workspace domain verification steps should be handled via browser instructions, ensuring the user authenticates directly with the provider.

---

## 6. Implementation Strategy

### Phase 1: Backend Foundation (Priority)

1. Setup Self-Hosted Appwrite schemas (Leads, Logs, Settings, Metrics).
2. Implement the Indian Name Parser logic.
3. Build the "MyEmailVerifier" and "AWS SES" integration modules.
4. Develop the Event Loop with Gaussian timing and ACID state management.
5. Implement SQS polling for bounce handling.

### Phase 2: Frontend Implementation

1. Develop the Dashboard (Status overview, controls).
2. Build the Template Editor (Spintax input).
3. Create the Lead Management view (Import/Edit).
4. Visualize the Metrics from the pre-calculated table.

### Phase 3: Testing

1. Unit testing of the Name Parser and Spintax logic.
2. Integration testing of the Verification -> Send flow.
3. Simulated power-loss recovery tests (ACID compliance check).